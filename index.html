<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Proximus Demo</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:#0b1020;color:#e6e8ef;margin:0}
    .wrap{max-width:1100px;margin:40px auto;padding:16px}
    .card{background:#121933;border-radius:14px;padding:16px;box-shadow:0 8px 30px rgba(0,0,0,.35);margin-bottom:16px}
    input,button,select,textarea{padding:10px 12px;border-radius:10px;border:1px solid #2a355b;background:#0f1429;color:#e6e8ef}
    button{cursor:pointer;background:#4c7dff;border-color:#4c7dff;font-weight:600}
    table{width:100%;border-collapse:collapse;margin-top:12px}
    th,td{padding:8px;border-bottom:1px solid #223;text-align:left}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .pill{display:inline-block;padding:2px 8px;border:1px solid #2e3b6e;border-radius:999px;font-size:12px}
    .muted{opacity:.85}
    #chartWrap{background:#0f1429;border:1px dashed #2a355b;border-radius:12px;padding:12px;margin-top:12px}
    .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px}
    .toolbar button{background:#2a355b;border-color:#2a355b}
  </style>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" defer></script>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h2>Proximus Demo</h2>

    <div id="login">
      <div class="row">
        <input id="u" placeholder="username" value="proximus" />
        <input id="p" placeholder="password" type="password" value="proximus123" />
        <button id="btnLogin">Login</button>
      </div>
      <p class="muted">Examples you can ask after login:
        <br>• <code>kpis for CO</code>
        <br>• <code>show failed records for GB limit 50</code>
        <br>• <code>pie chart of count by status for CO in red, green, blue</code>
        <br>• <code>horizontal stacked bar avg latency by country split by status top 8</code>
        <br>• <code>line chart avg latency by day</code>
        <br>• <code>doughnut of count by carrier</code>
      </p>
    </div>

    <div id="app" style="display:none">
      <div class="row">
        <button id="btnLogout">Logout</button>
        <select id="country"><option value="">All Countries</option><option>US</option><option>GB</option><option>DE</option><option>FR</option><option>BR</option><option>IN</option><option>MX</option><option>CO</option><option>ES</option><option>IT</option></select>
        <select id="status"><option value="">All Statuses</option><option>DELIVERED</option><option>FAILED</option><option>BLOCKED</option><option>PENDING</option></select>
        <button id="btnLoad">Load Data</button>
        <span id="kpi" class="pill"></span>
      </div>

      <div class="card" style="margin-top:16px">
        <h3>Ask about the data</h3>
        <div class="row" style="align-items:flex-start">
          <textarea id="q" rows="3" style="flex:1" placeholder="e.g., pie chart of count by status for CO in red, green, blue"></textarea>
          <button id="btnAsk" style="height:fit-content">Run</button>
        </div>
        <div class="toolbar">
          <button id="btnDownloadPng">Download PNG</button>
          <button id="btnClearChart">Clear Chart</button>
          <span id="answer" class="muted"></span>
        </div>
        <div id="chartWrap" style="display:none">
          <canvas id="chart" height="160"></canvas>
        </div>
      </div>

      <div class="card">
        <h3>Records</h3>
        <table>
          <thead><tr><th>Time</th><th>Country</th><th>Status</th><th>Carrier</th><th>Latency (ms)</th></tr></thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>
    </div>
  </div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const $ = sel => document.querySelector(sel);

  async function api(path, method='GET', body){
    const opts = { method, headers:{'Content-Type':'application/json'} };
    if(body) opts.body = JSON.stringify(body);
    const r = await fetch(path, opts);
    const j = await r.json().catch(()=>({}));
    if(!r.ok) throw new Error(j.error || JSON.stringify(j));
    return j;
  }

  function row(r){
    const dt = new Date(r.timestamp);
    return '<tr><td>'+dt.toLocaleString()+'</td><td>'+r.country+'</td><td>'+r.status+'</td><td>'+r.carrier+'</td><td>'+r.latency_ms+'</td></tr>';
  }

  async function login(){ await api('/api/login','POST',{username:$('#u').value, password:$('#p').value}); showApp(); }
  async function logout(){ await api('/api/logout','POST'); location.reload(); }
  function showApp(){ $('#login').style.display='none'; $('#app').style.display='block'; }

  async function loadData(){
    const qs = new URLSearchParams();
    if($('#country').value) qs.set('country',$('#country').value);
    if($('#status').value) qs.set('status',$('#status').value);
    const j = await api('/api/data?'+qs.toString());
    $('#tbody').innerHTML = j.map(row).join('');
    const k = computeKpis(j);
    $('#kpi').textContent = 'total '+k.total+' · delivered '+k.delivered+' · failed '+k.failed+' · blocked '+k.blocked+' · avgLatency '+Math.round(k.avgLatency)+'ms';
    cache.lastRows = j;
  }

  function computeKpis(rows){
    const total = rows.length;
    const delivered = rows.filter(r=>r.status==='DELIVERED').length;
    const failed = rows.filter(r=>r.status==='FAILED').length;
    const blocked = rows.filter(r=>r.status==='BLOCKED').length;
    const avgLatency = total ? rows.reduce((a,b)=>a+b.latency_ms,0)/total : 0;
    return { total, delivered, failed, blocked, avgLatency };
  }

  // --- Natural language → chart/summary parser ---
  // Supports: chart types, colors, top N, horizontal, stacked, groupBy, splitBy, metric (count|avg latency), by day
  function parseQuery(qRaw){
    const q = (qRaw||'').toLowerCase();

    // chart type
    let chartType = (q.match(/\b(pie|doughnut|donut|bar|line|radar|polar|polar area|polararea|area)\b/)||[])[1] || 'bar';
    if(chartType==='donut') chartType='doughnut';
    if(chartType==='polar area' || chartType==='polararea') chartType='polarArea';

    // metric
    let metric = /\bavg(eral)?e?\s*latency\b/.test(q) || /\bavg\b.*\blatency\b/.test(q) ? 'avg_latency' :
                 /\blatency\b/.test(q) && /\bavg\b/.test(q) ? 'avg_latency' : 'count';
    if(/\bcount\b/.test(q)) metric = 'count';

    // grouping
    let groupBy = (q.match(/\bby\s+(status|country|carrier|day|date)\b/)||[])[1] || 'status';
    if(groupBy==='date') groupBy='day';

    // split series (optional)
    let splitBy = (q.match(/\bsplit\s+by\s+(status|country|carrier)\b/)||[])[1] || null;

    // filters
    const mCountry = q.match(/\bfor\s+([a-z]{2})\b/);
    const mStatus  = q.match(/\b(delivered|failed|blocked|pending)\b/);
    const filters = {};
    if(mCountry) filters.country = mCountry[1].toUpperCase();
    if(mStatus)  filters.status  = mStatus[1].toUpperCase();

    // limit / top
    const topN = (q.match(/\btop\s+(\d{1,3})\b/)||[])[1];
    const limit = topN ? Math.min(parseInt(topN,10), 1000) : (q.match(/\blimit\s+(\d{1,4})\b/)||[])[1];
    const lim = limit ? Math.min(parseInt(limit,10), 1000) : 200;

    // display options
    const horizontal = /\bhorizontal\b/.test(q);
    const stacked    = /\bstacked\b/.test(q);

    // colors (comma-separated names)
    // supports basic CSS color names; if not specified we auto-generate palette
    let colors = null;
    const colMatch = q.match(/\bin\s+([a-z,\s]+)$/) || q.match(/\bcolors?\s*:\s*([a-z,\s]+)\b/);
    if(colMatch){
      colors = colMatch[1].split(/[, ]+/).map(s=>s.trim()).filter(Boolean);
    }

    // ask types
    const wantsChart = /\bchart|plot|graph|visual(ization)?\b/.test(q);
    const wantsRows  = /\bshow\b|\brecords?\b|\blist\b/.test(q);
    const wantsKpi   = /\bkpi[s]?\b/.test(q) || /summary/.test(q);

    return { chartType, metric, groupBy, splitBy, filters, lim, topN: topN?parseInt(topN,10):null, horizontal, stacked, colors, wantsChart, wantsRows, wantsKpi };
  }

  // Aggregation helpers
  function toDay(ts){ const d=new Date(ts); return new Date(d.getFullYear(), d.getMonth(), d.getDate()).toISOString().slice(0,10); }
  function groupRows(rows, key){
    const m=new Map();
    const keyFn = key==='day' ? (r)=>toDay(r.timestamp) : (r)=>String(r[key]).toUpperCase();
    rows.forEach(r=>{
      const k = keyFn(r);
      const g = m.get(k) || { sum:0, n:0, rows:[] };
      g.sum += r.latency_ms; g.n += 1; g.rows.push(r);
      m.set(k,g);
    });
    return m;
  }

  function sortAndTop(map, metric, topN){
    const arr = Array.from(map.entries()).map(([k,v])=>{
      const val = metric==='avg_latency' ? (v.sum/Math.max(1,v.n)) : v.n;
      return { key:k, val, n:v.n, sum:v.sum, rows:v.rows };
    });
    arr.sort((a,b)=>b.val - a.val);
    return typeof topN==='number' ? arr.slice(0,topN) : arr;
  }

  // Color palette generator (HSL)
  function palette(n, baseHue=210){
    const arr=[];
    for(let i=0;i<n;i++){
      const hue=(baseHue + i*360/n)%360;
      arr.push(`hsl(${hue} 70% 55%)`);
    }
    return arr;
  }

  // Chart.js renderer
  let chart;
  function renderChart({ type, labels, datasets, horizontal=false, stacked=false, title="Report"}){
    const ctx = document.getElementById('chart').getContext('2d');
    if(chart) chart.destroy();

    // Colors fallback
    datasets.forEach((ds, i)=>{
      if(!ds.backgroundColor){
        if(Array.isArray(ds.data)){
          const cols = palette(ds.data.length, (i*90)%360);
          ds.backgroundColor = type==='line' ? cols[0] : cols;
          ds.borderColor = ds.backgroundColor;
        } else {
          const col = palette(1,(i*90)%360)[0];
          ds.backgroundColor = col;
          ds.borderColor = col;
        }
      }
      if(type==='line'){ ds.tension=0.3; ds.fill=false; ds.pointRadius=2; }
    });

    const options = {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: true },
        title: { display: true, text: title }
      },
      scales: (type==='pie'||type==='doughnut'||type==='polarArea'||type==='radar') ? {} : {
        x: { stacked },
        y: { stacked, beginAtZero: true }
      },
      indexAxis: (horizontal && (type==='bar' || type==='line')) ? 'y' : 'x'
    };

    chart = new Chart(ctx, { type, data: { labels, datasets }, options });
    document.getElementById('chartWrap').style.display = 'block';
  }

  function formatTitle({chartType, metric, groupBy, splitBy, filters, topN}){
    const m = metric==='avg_latency' ? 'avg latency' : 'count';
    const parts = [`${chartType} ${m} by ${groupBy}`];
    if(splitBy) parts.push(`split by ${splitBy}`);
    if(filters.country) parts.push(`country=${filters.country}`);
    if(filters.status) parts.push(`status=${filters.status}`);
    if(topN) parts.push(`top ${topN}`);
    return parts.join(' · ');
  }

  // --- Q&A engine (upgraded) ---
  const cache = { lastRows: [] };

  async function ask(){
    const spec = parseQuery($('#q').value);
    const qs = new URLSearchParams();
    if(spec.filters.country) qs.set('country', spec.filters.country);
    if(spec.filters.status)  qs.set('status',  spec.filters.status);
    qs.set('limit', String(spec.lim));

    const rows = await api('/api/data?'+qs.toString());
    cache.lastRows = rows;

    // Defaults if no explicit intent
    if(!spec.wantsChart && !spec.wantsRows && !spec.wantsKpi){ spec.wantsChart=true; }

    $('#answer').textContent = '';
    $('#chartWrap').style.display = 'none';

    // KPIs
    if(spec.wantsKpi){
      const k = computeKpis(rows);
      $('#answer').textContent =
        `KPIs${spec.filters.country?` for ${spec.filters.country}`:''}${spec.filters.status?` [${spec.filters.status}]`:''}: ` +
        `total ${k.total}, delivered ${k.delivered}, failed ${k.failed}, blocked ${k.blocked}, avgLatency ${Math.round(k.avgLatency)}ms`;
    }

    // Rows
    if(spec.wantsRows){
      $('#tbody').innerHTML = rows.map(r=>row(r)).join('');
      if(!spec.wantsKpi) {
        const k = computeKpis(rows);
        $('#answer').textContent = `Loaded ${rows.length} record(s). Delivered ${k.delivered}, Failed ${k.failed}, Blocked ${k.blocked}.`;
      }
    }

    // Charts
    if(spec.wantsChart){
      // Aggregate primary grouping
      if(!['status','country','carrier','day'].includes(spec.groupBy)) spec.groupBy='status';

      if(!spec.splitBy){
        // single dataset
        const grouped = groupRows(rows, spec.groupBy);
        let arr = sortAndTop(grouped, spec.metric, spec.topN);
        const labels = arr.map(x=>x.key);
        const values = arr.map(x=> spec.metric==='avg_latency' ? Math.round(x.sum/Math.max(1,x.n)) : x.n);

        const ds = {
          label: spec.metric==='avg_latency' ? 'Avg latency (ms)' : 'Count',
          data: values
        };

        // colors (if given)
        if(spec.colors && (spec.chartType==='pie' || spec.chartType==='doughnut' || spec.chartType==='polarArea')){
          ds.backgroundColor = spec.colors;
        } else if (spec.colors && spec.chartType!=='line'){
          ds.backgroundColor = spec.colors;
        }

        renderChart({
          type: spec.chartType==='area' ? 'line' : spec.chartType,
          labels,
          datasets: [ds],
          horizontal: spec.horizontal,
          stacked: spec.stacked,
          title: formatTitle(spec)
        });
      } else {
        // multi-series: splitBy
        if(spec.splitBy===spec.groupBy){ spec.splitBy=null; return ask(); } // avoid same dim
        const primary = groupRows(rows, spec.groupBy);
        // Collect all secondary keys to build aligned datasets
        const secondaryKeys = new Set();
        const buckets = new Map(); // primaryKey -> Map(secondaryKey -> {sum,n})

        rows.forEach(r=>{
          const pk = spec.groupBy==='day' ? toDay(r.timestamp) : String(r[spec.groupBy]).toUpperCase();
          const sk = String(r[spec.splitBy]).toUpperCase();
          const inner = buckets.get(pk) || new Map();
          const cell = inner.get(sk) || { sum:0, n:0 };
          cell.sum += r.latency_ms; cell.n += 1;
          inner.set(sk, cell);
          buckets.set(pk, inner);
          secondaryKeys.add(sk);
        });

        // Sort primary by metric and take topN
        let primArr = sortAndTop(primary, spec.metric, spec.topN);
        const labels = primArr.map(x=>x.key);
        const secList = Array.from(secondaryKeys).sort();

        // Build datasets per secondary key
        const datasets = secList.map((sk, idx)=>{
          const data = labels.map(pk=>{
            const inner = buckets.get(pk);
            const cell = inner ? inner.get(sk) : null;
            if(!cell) return 0;
            return spec.metric==='avg_latency' ? Math.round(cell.sum/Math.max(1,cell.n)) : cell.n;
          });
          const ds = { label: sk, data };
          // color
          if(spec.colors && spec.colors[idx]) ds.backgroundColor = spec.colors[idx];
          return ds;
        });

        renderChart({
          type: spec.chartType==='area' ? 'line' : spec.chartType,
          labels,
          datasets,
          horizontal: spec.horizontal,
          stacked: spec.stacked,
          title: formatTitle(spec)
        });
      }
    }
  }

  // Download PNG
  function downloadPng(){
    const canvas = document.getElementById('chart');
    if(!canvas) return;
    const url = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = 'report.png';
    a.click();
  }

  // wire up events
  $('#btnLogin').onclick = login;
  $('#btnLogout').onclick = logout;
  $('#btnLoad').onclick = loadData;
  $('#btnAsk').onclick = ask;
  $('#btnDownloadPng').onclick = downloadPng;
  $('#btnClearChart').onclick = () => { const c=document.getElementById('chart'); if(c){ c.getContext('2d').clearRect(0,0,c.width,c.height);} document.getElementById('chartWrap').style.display='none'; $('#answer').textContent=''; };

  // auto-show if session exists
  fetch('/api/me').then(r=>r.json()).then(j=>{ if(j.authenticated) showApp(); });
});
</script>
</body>
</html>
